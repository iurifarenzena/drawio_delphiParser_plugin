//import parseDelphiUnitToUml from "../src/delphiParserToUml.js"
//import {CreateNewMethod} from "../src/model/delphiMethod.js"
import { parseTextToUnit } from "../src/model/delphiUnit.js"
import {StackLinesIterator}from "../src/delphiParserToActivity"

//var text = "unit PartTimeDataManager; \n \ninterface \n \nuses \n  IntfDataPartTimes, \n  Collectn; \n \ntype \n  TPartTimeData = class \n    NestID: integer; \n    NestedPartID: integer; \n    PartTime: double; \n    constructor create(aNestedPartID,aNestID: integer; aPartTime: double); \n  end; \n \n  TPartTimeDataManager = class \n   private \n    fPartTimeAccumulator: IPartTimeAccumulator; \n    fPartTimeProportionList: TSNCollection; \n    procedure NormalizePartTimeProportionList(aPartTimeProportionList: TSNCollection); \n    procedure ApplyPartTimeProportionList(aProcessNum: integer; aTime: double; aValueType: PartTimeValue_Enum); \n   public \n    SubMultiplier: integer; \n    constructor create; \n    destructor Destroy; override; \n    procedure SetPartTimeAccumulator(aPartTimeAccumulator: IPartTimeAccumulator); \n    procedure SetPartTimeProportionList(aPartTimeProportionList: TSNCollection); \n    procedure AddPartCuttingTime(aProcessNum: integer; aTime: double); \n    procedure AddPartPiercingTime(aProcessNum: integer; aTime: double); \n    procedure AddPartTravelTime(aProcessNum: integer; aTime: double); \n  end; \n \n \nimplementation \n \nuses \n  PartTimeProportion, \n  wsk; \n \n{ TPartTimeDataManager } \n \n{----------------------------------------------------------------------------- \n  Procedure: AddPartCuttingTime \n  Author:    jamess \n  Date:      06-Jan-2016 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.AddPartCuttingTime(aProcessNum: integer; aTime: double); \nbegin \n  if (fPartTimeProportionList <> nil) and (fPartTimeProportionList.Count > 0) and (aTime > 0) then \n    ApplyPartTimeProportionList(aProcessNum,aTime,PartTimeValue_CuttingTime); \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: AddPartPiercingTime \n  Author:    jamess \n  Date:      06-Jan-2016 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.AddPartPiercingTime(aProcessNum: integer; aTime: double); \nbegin \n  if (fPartTimeProportionList <> nil) and (fPartTimeProportionList.Count > 0) and (aTime > 0) then \n    ApplyPartTimeProportionList(aProcessNum,aTime,PartTimeValue_PierceTime); \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: AddPartTravelTime \n  Author:    jamess \n  Date:      06-Jan-2016 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.AddPartTravelTime(aProcessNum: integer; aTime: double); \nbegin \n  if (fPartTimeProportionList <> nil) and (fPartTimeProportionList.Count > 0) and (aTime > 0) then \n    ApplyPartTimeProportionList(aProcessNum,aTime,PartTimeValue_TravelTime); \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: ApplyPartTimeProportionList \n  Author:    jamess \n  Date:      17-Dec-2015 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.ApplyPartTimeProportionList(aProcessNum: integer; aTime: double; aValueType: PartTimeValue_Enum); \nvar \n  i: integer; \n  lPTPData: TPartTimeProportionData; \nbegin \n  if fPartTimeAccumulator <> nil then \n  begin \n    if (fPartTimeProportionList <> nil) and (fPartTimeProportionList.Count > 0) then \n    begin \n      if (SubMultiplier > 1) then \n        aTime := aTime * SubMultiplier; \n      for i := 0 to fPartTimeProportionList.Count - 1 do \n      begin \n        lPTPData := TPartTimeProportionData(fPartTimeProportionList[i]); \n        fPartTimeAccumulator.AddPartTime(lPTPData.NestID,aProcessNum,(aTime * lPTPData.TimeProportion),aValueType); \n      end; \n    end; \n  end; \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: create \n  Author:    jamess \n  Date:      16-Dec-2015 \n  Notes: \n-----------------------------------------------------------------------------} \nconstructor TPartTimeDataManager.create; \nbegin \n  inherited create; \n  fPartTimeAccumulator := nil; \n  SubMultiplier := 1; \nend; \n \n \n{----------------------------------------------------------------------------- \n  Procedure: destroy \n  Author:    jamess \n  Date:      16-Dec-2015 \n  Notes: \n-----------------------------------------------------------------------------} \ndestructor TPartTimeDataManager.destroy; \nbegin \n//  fPartTimeAccumulator.Release; \n//  fPartTimeDataList.Destroy; \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: NormalizePartTimeProportionList \n  Author:    jamess \n  Date:      17-Dec-2015 \n  Notes:     See if all proportions for this move add up to 1, and maybe fix... \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.NormalizePartTimeProportionList(aPartTimeProportionList: TSNCollection); \nvar \n  i: integer; \n  lPTPTotal: double; \n  lPTPData: TPartTimeProportionData; \nbegin \n  lPTPTotal := 0.0; \n  for i := 0 to aPartTimeProportionList.Count - 1 do \n  begin \n    lPTPData := TPartTimeProportionData(aPartTimeProportionList[i]); \n    lPTPTotal := lPTPTotal + lPTPData.TimeProportion; \n  end; \n  if notAlmostZero(1 - lPTPTotal) then  // Something went wrong determining part proportions. \n  begin \n    if lPTPTotal > 1 then  // only normalize if proportions would increase total time \n    begin \n      for i := 0 to aPartTimeProportionList.Count - 1 do \n      begin \n        lPTPData := TPartTimeProportionData(aPartTimeProportionList[i]); \n        // this modifies the list attached to the TNCData, but that should be ok. \n        lPTPData.TimeProportion := lPTPData.TimeProportion * 1/lPTPTotal; \n      end; \n    end; \n  end; \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: SetPartTimeAccumulator \n  Author:    jamess \n  Date:      21-Dec-2015 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.SetPartTimeAccumulator(aPartTimeAccumulator: IPartTimeAccumulator); \nbegin \n  fPartTimeAccumulator := aPartTimeAccumulator; \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: SetPartTimeProportionList \n  Author:    jamess \n  Date:      06-Jan-2016 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.SetPartTimeProportionList(aPartTimeProportionList: TSNCollection); \nbegin \n  if aPartTimeProportionList <> fPartTimeProportionList then \n  begin \n    fPartTimeProportionList := aPartTimeProportionList; \n    if (fPartTimeProportionList <> nil) and (fPartTimeProportionList.Count > 0) then \n      NormalizePartTimeProportionList(fPartTimeProportionList); \n  end; \nend; \n \n{ TPartTimeData } \n \n{----------------------------------------------------------------------------- \n  Procedure: create \n  Author:    jamess \n  Date:      17-Dec-2015 \n  Notes: \n-----------------------------------------------------------------------------} \nconstructor TPartTimeData.create(aNestedPartID,aNestID: integer; aPartTime: double); \nbegin \n  NestedPartID := aNestedPartID; \n  NestID := aNestID; \n  PartTime := aPartTime; \nend; \n \nend.";
//var text = "unit TMSScripterFactory; \n \ninterface \n \nuses \n  atPascal; \n \nfunction CreateScripter: TatPascalScripter; \n \nimplementation \n \nuses \n  ap_Classes, ap_Windows, ap_System, ap_SysUtils, ap_Dialogs, ap_Math, \n  ap_Variants, ap_IniFiles, ap_Messages, ap_Controls, ap_Forms, ap_StdCtrls, \n  sntms_System, sntms_smallPost, sntms_Small, sntms_Collectn, sntms_post2, \n  sntms_PostPST, sntms_dataNC, sntms_dataNCBevel, sntms_SheetInfoObj, \n  sntms_DataGeoLiteElement, sntms_NCICFGReader, System.SysUtils; \n \nprocedure LoadNeededScriptLibraries(aScripter: TatPascalScripter); \nbegin \n  try \n      // Add Classes \n    aScripter.AddLibrary(TatClassesLibrary); \n    aScripter.AddLibrary(TatWindowsLibrary); \n    aScripter.AddLibrary(TatDelphiSystemLibrary); \n    aScripter.AddLibrary(TatSysUtilsLibrary); \n    aScripter.AddLibrary(TatDialogsLibrary); \n    aScripter.AddLibrary(TatMathLibrary); \n    aScripter.AddLibrary(TatVariantsLibrary); \n    aScripter.AddLibrary(TatIniFilesLibrary); \n    aScripter.AddLibrary(TatMessagesLibrary); \n    aScripter.AddLibrary(TatControlsLibrary); \n    aScripter.AddLibrary(TatFormsLibrary); \n    aScripter.AddLibrary(TatStdCtrlsLibrary); \n    aScripter.AddLibrary(TatSNSystemLibrary); \n    // Small \n    aScripter.AddLibrary(TatsmallPostLibrary); \n    aScripter.AddLibrary(TatSmallLibrary); \n    aScripter.AddLibrary(TatCollectnLibrary); \n    aScripter.AddLibrary(TatPost2Library); \n    // PostPST \n    aScripter.AddLibrary(TatPostPSTLibrary); \n    aScripter.AddLibrary(TatdataNCLibrary); \n    aScripter.AddLibrary(TatdataNCBevelLibrary); \n    aScripter.AddLibrary(TatSheetInfoObjLibrary); \n    aScripter.AddLibrary(TatDataGeoLiteElementLibrary); \n    aScripter.AddLibrary(TatNCICFGReaderLibrary); \n  except \n      on E: Exception do \n      begin \n        raise Exception.Create('LoadNeededScriptLibraries failed with message: ' + E.Message); \n      end; \n  end; \nend; \n \nprocedure RegisterGlobalConstants(aScripter: TatPascalScripter); \nbegin \n  aScripter.AddConstant('Pi', Pi); \nend; \n \nprocedure RegisterGlobalMethods \n  (aScripter: TatPascalScripter); \nbegin \n \nend; \n \nfunction CreateScripter : TatPascalScripter; \nvar \n  lScripter: TatPascalScripter; \nbegin; \n  lScripter := TatPascalScripter.create(nil); \n  RegisterGlobalMethods(lScripter); \n  RegisterGlobalConstants(lScripter); \n  LoadNeededScriptLibraries(lScripter); \n  Result := lScripter; \nend; \n \nend.";
//var text = "unit PostScript_TMS_Optimized; \n \ninterface \n \nuses \n  DataError, \n  Script_Base, \n  // Boundary - TMS Scripting \n  atPascal; \n \ntype \n  /// <summary>Scripting with TMS Scripter with optimizations: PCU, Using multiple scripts, Uses another pas, Will not parse and fix scripts</summary> \n  /// <remarks>Used when ScriptEngine:4 in the PST</remarks> \n  TPostScript_TMS_Optimized = class(TPostScripting) \n  private \n    fTMSScripter: TatPascalScripter; \n    fDoSavePrecompiledUnit: Boolean; \n    fCompileErrorRow: integer; \n    fCompileErrorCol: integer; \n    fCompileErrorMsg: string; \n \n    procedure SetScriptFile(const Value: string); override; \n    Procedure LoadScriptFile; \n    procedure Event_ScripterCompileError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n    procedure Event_ScripterRuntimeError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n    procedure HandleScripterError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n \n    function GetTMSErrorMessage(const aMainMessage: string) : string; \n    function SetCurrentScriptFromLoadedLibs(lScriptNameNoExt: string): Boolean; \n    procedure SaveScriptAsPrecompiledUnit(const aPCUPath: string); \n    procedure LoadScripter(const postFolderPath: string); \n \n  protected \n    function GetScriptEngineName: string; override; \n \n  public \n    constructor create(aErrorLog: TErrorLog; const postFolderPath: string; const aDoSaveScriptsAsPCU : Boolean); \n    destructor Destroy; override; \n \n    procedure CallNoParamsMethod(const str: string); override; \n \n    property CompileErrorRow: integer read fCompileErrorRow write fCompileErrorRow; \n    property CompileErrorCol: integer read fCompileErrorCol write fCompileErrorCol; \n    property CompileErrorMsgStr: string read fCompileErrorMsg; \n \n  end; \n \nimplementation \n \nuses \n  TMSScripterFactory, \n  ConstVarPost, \n  Small, \n  // Windows API - Self \n  System.IOUtils, \n  System.Variants, \n  StrUtils, \n  sysutils; \n \nConst \n  C_SourceFileExt: string = '.pas'; \n  C_CompiledFileExt: string = '.pcu'; \n \nconstructor TPostScript_TMS_Optimized.create(aErrorLog: TErrorLog; const postFolderPath: string; const aDoSaveScriptsAsPCU : Boolean); \nbegin \n  inherited create(aErrorLog); \n  fDoSavePrecompiledUnit := aDoSaveScriptsAsPCU; \n  fCompileErrorRow := 0; \n  fCompileErrorCol := 0; \n  NullStrictConvert := false; \n  LoadScripter(postFolderPath); \nend; \n \n{ ************************************************************** } \n// Procedure: Destroy \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \ndestructor TPostScript_TMS_Optimized.Destroy; \nbegin \n  fTMSScripter.Free; \n  inherited; \nend; \n \n{ ************************************************************** } \n// Procedure: LoadScripter \n// Author:    iurif \n// Date:      18-Jan-2021 \n// Notes:     TFS#111716 \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.LoadScripter(const postFolderPath: string); \nbegin \n  try \n    fTMSScripter := CreateScripter; \n    fTMSScripter.OnCompileError := Event_ScripterCompileError; \n    fTMSScripter.OnRuntimeError := Event_ScripterRuntimeError; \n    fTMSScripter.LibOptions.UseScriptFiles := true; \n    fTMSScripter.LibOptions.SourceFileExt := C_SourceFileExt; \n    fTMSScripter.LibOptions.CompiledFileExt := C_CompiledFileExt; \n    fTMSScripter.LibOptions.SearchPath.Add(postFolderPath); \n    fTMSScripter.OptionExplicit := true; \n    fTMSScripter.ShortBooleanEval := true; \n  except \n    on E: Exception do \n    begin \n      AddToErrorLog(ScriptError, \n        'Loading TMS Scripter Raised Exception: \" ' + E.Message + ' \"'); \n      fResultCode := PostStatus_ScriptError; \n      fCriticalFailure := true; \n    end; \n  end; \nend; \n \n{ ************************************************************** } \n// Function: GetScriptEngineName \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.GetScriptEngineName: string; \nbegin \n  Result := 'TMS Scripter - Engine 4'; \nend; \n \n{ ************************************************************** } \n// Procedure: SetScriptFile \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.SetScriptFile(const Value: string); \nbegin \n  inherited; \n  LoadScriptFile; \nend; \n \n{ ************************************************************** } \n// Procedure: LoadScriptFile \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.LoadScriptFile; \nvar \n  ldir, lScriptName, lext: string; \nbegin \n  fCompileErrorRow := 0; \n  fCompileErrorCol := 0; \n \n  FSplit(fScriptFile, ldir, lScriptName, lext); \n \n  if not SetCurrentScriptFromLoadedLibs(lScriptName) then \n  begin \n    try \n      begin \n        fTMSScripter.LoadLibrary(lScriptName); \n        // Loaded script gets added to Scripts list \n        fTMSScripter.CurrentScript := fTMSScripter.Scripts.Items[fTMSScripter.Scripts.Count - 1]; \n      end \n    except \n      on E: EAbort do \n      begin \n        AddToErrorLog(ScriptError, 'TMS: Script loading has been aborted'); \n        fCriticalFailure := true; \n      end; \n      on E: Exception do \n      begin \n        fTMSScripter.CurrentScript.GetRowColFromSource(fTMSScripter.CurrentScript.Parser.ScanningInputPos, fCompileErrorRow, fCompileErrorCol); \n        AddToErrorLog(ScriptError, GetTMSErrorMessage(E.ClassName + ': ' + E.Message)); \n        fCriticalFailure := true; \n      end; \n    end; \n  end; \n \n  if (fDoSavePrecompiledUnit) then \n    SaveScriptAsPrecompiledUnit(TPath.Combine(ldir, lScriptName + C_CompiledFileExt)); \nend; \n \n{ ************************************************************** } \n// Function: SetCurrentScriptFromLoadedLibs \n// Author:   iurif \n// Date:     23-Apr-2020 \n// Notes:    TFS#85504 \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.SetCurrentScriptFromLoadedLibs(lScriptNameNoExt: string): Boolean; \nvar \n  I: integer; \nbegin \n  Result := false; \n  for I := 0 to fTMSScripter.Scripts.Count - 1 do \n  begin \n    if CompareText(fTMSScripter.Scripts.Items[I].UnitName, lScriptNameNoExt) = 0 then \n    begin \n      fTMSScripter.CurrentScript := fTMSScripter.Scripts.Items[I]; \n      Result := true; \n      break; \n    end; \n  end; \nend; \n \n{ ************************************************************** } \n// Procedure: SavePrecompileUnit \n// Author:    iurif \n// Date:      23-Apr-2020 \n// Notes:     TFS#85584 \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.SaveScriptAsPrecompiledUnit(const aPCUPath: string); \nbegin \n  if (not(fCriticalFailure)) and fTMSScripter.CurrentScript.FileName.EndsWith(C_SourceFileExt) then \n  begin \n    fTMSScripter.CurrentScript.SaveCodeToFile(aPCUPath); \n  end; \nend; \n \n{ ************************************************************** } \n// Procedure: CallNoParamsMethod \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.CallNoParamsMethod(const str: string); \nbegin \n  inherited; \n  if not fCriticalFailure then \n    fTMSScripter.ExecuteSubroutine(str); \nend; \n \n{ ************************************************************** } \n// Procedure: Event_ScripterCompileError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.Event_ScripterCompileError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  HandleScripterError(Sender, msg, row, col, ShowException); \n  fResultCode := PostStatus_SyntaxError; \nend; \n \n{ ************************************************************** } \n// Procedure: Event_ScripterRuntimeError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.Event_ScripterRuntimeError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  HandleScripterError(Sender, msg, row, col, ShowException); \n  fResultCode := PostStatus_ScriptError; \nend; \n \n{ ************************************************************** } \n// Procedure: HandleScripterError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.HandleScripterError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  fCompileErrorRow := row; \n  fCompileErrorCol := col; \n  fCompileErrorMsg := IfThen(fCompileErrorMsg.Length > 0, fCompileErrorMsg + sLineBreak, '') + msg; \n  AddToErrorLog(ScriptError, GetTMSErrorMessage(msg)); \n  ShowException := false; \n  fCriticalFailure := true; \nend; \n \n{ ************************************************************** } \n// Function: GetTMSErrorMessage \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.GetTMSErrorMessage(const aMainMessage: string) : string; \nbegin \n  Result := Format('TMS Script ERROR - (Line %0:d,%1:d) - %2:s.%4:sFileName - %3:s.', \n                    [fCompileErrorRow, fCompileErrorCol, aMainMessage, fScriptFile, sLineBreak]); \n // TODO_TechDebt: try to get back -> 'Error Code Line - ' + FTMSScripter.SourceCode[Max(Row-1,0)]); \nend; \n \nend.unit PostScript_TMS_Optimized; \n \ninterface \n \nuses \n  DataError, \n  Script_Base, \n  // Boundary - TMS Scripting \n  atPascal; \n \ntype \n  /// <summary>Scripting with TMS Scripter with optimizations: PCU, Using multiple scripts, Uses another pas, Will not parse and fix scripts</summary> \n  /// <remarks>Used when ScriptEngine:4 in the PST</remarks> \n  TPostScript_TMS_Optimized = class(TPostScripting) \n  private \n    fTMSScripter: TatPascalScripter; \n    fDoSavePrecompiledUnit: Boolean; \n    fCompileErrorRow: integer; \n    fCompileErrorCol: integer; \n    fCompileErrorMsg: string; \n \n    procedure SetScriptFile(const Value: string); override; \n    Procedure LoadScriptFile; \n    procedure Event_ScripterCompileError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n    procedure Event_ScripterRuntimeError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n    procedure HandleScripterError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n \n    function GetTMSErrorMessage(const aMainMessage: string) : string; \n    function SetCurrentScriptFromLoadedLibs(lScriptNameNoExt: string): Boolean; \n    procedure SaveScriptAsPrecompiledUnit(const aPCUPath: string); \n    procedure LoadScripter(const postFolderPath: string); \n \n  protected \n    function GetScriptEngineName: string; override; \n \n  public \n    constructor create(aErrorLog: TErrorLog; const postFolderPath: string; const aDoSaveScriptsAsPCU : Boolean); \n    destructor Destroy; override; \n \n    procedure CallNoParamsMethod(const str: string); override; \n \n    property CompileErrorRow: integer read fCompileErrorRow write fCompileErrorRow; \n    property CompileErrorCol: integer read fCompileErrorCol write fCompileErrorCol; \n    property CompileErrorMsgStr: string read fCompileErrorMsg; \n \n  end; \n \nimplementation \n \nuses \n  TMSScripterFactory, \n  ConstVarPost, \n  Small, \n  // Windows API - Self \n  System.IOUtils, \n  System.Variants, \n  StrUtils, \n  sysutils; \n \nConst \n  C_SourceFileExt: string = '.pas'; \n  C_CompiledFileExt: string = '.pcu'; \n \nconstructor TPostScript_TMS_Optimized.create(aErrorLog: TErrorLog; const postFolderPath: string; const aDoSaveScriptsAsPCU : Boolean); \nbegin \n  inherited create(aErrorLog); \n  fDoSavePrecompiledUnit := aDoSaveScriptsAsPCU; \n  fCompileErrorRow := 0; \n  fCompileErrorCol := 0; \n  NullStrictConvert := false; \n  LoadScripter(postFolderPath); \nend; \n \n{ ************************************************************** } \n// Procedure: Destroy \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \ndestructor TPostScript_TMS_Optimized.Destroy; \nbegin \n  fTMSScripter.Free; \n  inherited; \nend; \n \n{ ************************************************************** } \n// Procedure: LoadScripter \n// Author:    iurif \n// Date:      18-Jan-2021 \n// Notes:     TFS#111716 \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.LoadScripter(const postFolderPath: string); \nbegin \n  try \n    fTMSScripter := CreateScripter; \n    fTMSScripter.OnCompileError := Event_ScripterCompileError; \n    fTMSScripter.OnRuntimeError := Event_ScripterRuntimeError; \n    fTMSScripter.LibOptions.UseScriptFiles := true; \n    fTMSScripter.LibOptions.SourceFileExt := C_SourceFileExt; \n    fTMSScripter.LibOptions.CompiledFileExt := C_CompiledFileExt; \n    fTMSScripter.LibOptions.SearchPath.Add(postFolderPath); \n    fTMSScripter.OptionExplicit := true; \n    fTMSScripter.ShortBooleanEval := true; \n  except \n    on E: Exception do \n    begin \n      AddToErrorLog(ScriptError, \n        'Loading TMS Scripter Raised Exception: \" ' + E.Message + ' \"'); \n      fResultCode := PostStatus_ScriptError; \n      fCriticalFailure := true; \n    end; \n  end; \nend; \n \n{ ************************************************************** } \n// Function: GetScriptEngineName \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.GetScriptEngineName: string; \nbegin \n  Result := 'TMS Scripter - Engine 4'; \nend; \n \n{ ************************************************************** } \n// Procedure: SetScriptFile \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.SetScriptFile(const Value: string); \nbegin \n  inherited; \n  LoadScriptFile; \nend; \n \n{ ************************************************************** } \n// Procedure: LoadScriptFile \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.LoadScriptFile; \nvar \n  ldir, lScriptName, lext: string; \nbegin \n  fCompileErrorRow := 0; \n  fCompileErrorCol := 0; \n \n  FSplit(fScriptFile, ldir, lScriptName, lext); \n \n  if not SetCurrentScriptFromLoadedLibs(lScriptName) then \n  begin \n    try \n      begin \n        fTMSScripter.LoadLibrary(lScriptName); \n        // Loaded script gets added to Scripts list \n        fTMSScripter.CurrentScript := fTMSScripter.Scripts.Items[fTMSScripter.Scripts.Count - 1]; \n      end \n    except \n      on E: EAbort do \n      begin \n        AddToErrorLog(ScriptError, 'TMS: Script loading has been aborted'); \n        fCriticalFailure := true; \n      end; \n      on E: Exception do \n      begin \n        fTMSScripter.CurrentScript.GetRowColFromSource(fTMSScripter.CurrentScript.Parser.ScanningInputPos, fCompileErrorRow, fCompileErrorCol); \n        AddToErrorLog(ScriptError, GetTMSErrorMessage(E.ClassName + ': ' + E.Message)); \n        fCriticalFailure := true; \n      end; \n    end; \n  end; \n \n  if (fDoSavePrecompiledUnit) then \n    SaveScriptAsPrecompiledUnit(TPath.Combine(ldir, lScriptName + C_CompiledFileExt)); \nend; \n \n{ ************************************************************** } \n// Function: SetCurrentScriptFromLoadedLibs \n// Author:   iurif \n// Date:     23-Apr-2020 \n// Notes:    TFS#85504 \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.SetCurrentScriptFromLoadedLibs(lScriptNameNoExt: string): Boolean; \nvar \n  I: integer; \nbegin \n  Result := false; \n  for I := 0 to fTMSScripter.Scripts.Count - 1 do \n  begin \n    if CompareText(fTMSScripter.Scripts.Items[I].UnitName, lScriptNameNoExt) = 0 then \n    begin \n      fTMSScripter.CurrentScript := fTMSScripter.Scripts.Items[I]; \n      Result := true; \n      break; \n    end; \n  end; \nend; \n \n{ ************************************************************** } \n// Procedure: SavePrecompileUnit \n// Author:    iurif \n// Date:      23-Apr-2020 \n// Notes:     TFS#85584 \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.SaveScriptAsPrecompiledUnit(const aPCUPath: string); \nbegin \n  if (not(fCriticalFailure)) and fTMSScripter.CurrentScript.FileName.EndsWith(C_SourceFileExt) then \n  begin \n    fTMSScripter.CurrentScript.SaveCodeToFile(aPCUPath); \n  end; \nend; \n \n{ ************************************************************** } \n// Procedure: CallNoParamsMethod \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.CallNoParamsMethod(const str: string); \nbegin \n  inherited; \n  if not fCriticalFailure then \n    fTMSScripter.ExecuteSubroutine(str); \nend; \n \n{ ************************************************************** } \n// Procedure: Event_ScripterCompileError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.Event_ScripterCompileError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  HandleScripterError(Sender, msg, row, col, ShowException); \n  fResultCode := PostStatus_SyntaxError; \nend; \n \n{ ************************************************************** } \n// Procedure: Event_ScripterRuntimeError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.Event_ScripterRuntimeError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  HandleScripterError(Sender, msg, row, col, ShowException); \n  fResultCode := PostStatus_ScriptError; \nend; \n \n{ ************************************************************** } \n// Procedure: HandleScripterError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.HandleScripterError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  fCompileErrorRow := row; \n  fCompileErrorCol := col; \n  fCompileErrorMsg := IfThen(fCompileErrorMsg.Length > 0, fCompileErrorMsg + sLineBreak, '') + msg; \n  AddToErrorLog(ScriptError, GetTMSErrorMessage(msg)); \n  ShowException := false; \n  fCriticalFailure := true; \nend; \n \n{ ************************************************************** } \n// Function: GetTMSErrorMessage \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.GetTMSErrorMessage(const aMainMessage: string) : string; \nbegin \n  Result := Format('TMS Script ERROR - (Line %0:d,%1:d) - %2:s.%4:sFileName - %3:s.', \n                    [fCompileErrorRow, fCompileErrorCol, aMainMessage, fScriptFile, sLineBreak]); \n // TODO_TechDebt: try to get back -> 'Error Code Line - ' + FTMSScripter.SourceCode[Max(Row-1,0)]); \nend; \n \nend.";

// var text = "TNCColl = class(TCadColl)\r\n  private\r\n    SimulateNoteStr: boolean; \/\/ Uses for simulation.\r\n    procedure GetNCByContinuity_AsNCOllsRegular(AContourNCList: TSncollection);\r\n  protected\r\n    function GetProcessNum1: byte; override;\r\n  public\r\n    NID: Integer; { Nest ID }\r\n  end;"

var text = "unit NestToNestedPartMonitor;\n{$I SigmaNEST.inc}\n{\n  Author:   iuri.f\n  Date:     21-Dec-2021\n  Notes:    TFS#136728\n  this unit contains functionalities for allowing to monitor\n  changes in the number of NestedParts in the Nest (using event publisher)\n\n  *TAutoFixNestedPartTempIDSubscription*\n    based on these changes it manages each NestedPart's TempID to ensure integrity*\n      *TempID must be unique per each instance of a NestedPart\n}\n\ninterface\n\nuses\n  DataNest, EventPublisherInt, System.Generics.Collections;\n\ntype\n  TAutoFixNestedPartTempIDSubscription = class\n  private\n    fNest: TNest;\n    fOnModifyNestedPartsSubscription: IEventSubscription;\n    fLastNestedPartsListCount: Integer; // used for skipping FixNestedPartsTempID if there are no new parts\n    fPartsHaveBeenNested: Boolean; // used for fixing TNest's NCList collections' PID if necessary\n    procedure HandleNestedPartsListModified(ASender: TObject; var AData);\n    procedure Start;\n    procedure Stop;\n  public\n    constructor Create(const aNest: TNest);\n    destructor Destroy; override;\n\n  end;\n\n  TNestedPartTempIDMgr = class\n    class function StartWatchingForAutoFixingNewlyNestedPartsTempIDs(const aNest: TNest): TAutoFixNestedPartTempIDSubscription;\n    class procedure ExtractDuplicateTempIdIndexesAndMaxTempIDFromNestedPartsList(const aNest: TNest; aWrongTempIDsIndexes: TList<Integer>; var lMaxTempID: Integer);\n    class procedure FixNestedPartsTempIDs(const aNest: TNest);\n    class procedure FixNCListPIDsWithNestedPartsTempID(const aNest: TNest);\n  end;\n\nimplementation\n\nuses\n  data, datanccoll, DataNestedPart, System.Classes;\n\n{$REGION 'TAutoFixNestedPartTempIDSubscription implementation'}\n\n{ *************************************************\n  Author:    iuri.f\n  Date:      21-Dec-2021\n  Notes:     TFS#136728\n  ************************************************* }\nconstructor TAutoFixNestedPartTempIDSubscription.Create(const aNest: TNest);\nbegin\n  fNest := aNest;\n  fPartsHaveBeenNested := false;\nend;\n\n{ *************************************************\n  Author:    iuri.f\n  Date:      21-Dec-2021\n  Notes:     TFS#136728\n  ************************************************* }\ndestructor TAutoFixNestedPartTempIDSubscription.Destroy;\nbegin\n  Stop;\nend;\n\n{ *************************************************\n  Author:    iuri.f\n  Date:      21-Dec-2021\n  Notes:     TFS#136728\n  ************************************************* }\nprocedure TAutoFixNestedPartTempIDSubscription.HandleNestedPartsListModified(ASender: TObject; var AData);\nbegin\n  if fLastNestedPartsListCount < fNest.DList.Count then\n  begin\n    fPartsHaveBeenNested := true;\n    TNestedPartTempIDMgr.FixNestedPartsTempIDs(fNest);\n  end;\nend;\n\n{ *************************************************\n  Author:    iuri.f\n  Date:      21-Dec-2021\n  Notes:     TFS#136728 to be called before starting\n             operations that may copy nested parts\n  ************************************************* }\nprocedure TAutoFixNestedPartTempIDSubscription.Start;\nbegin\n  fLastNestedPartsListCount := fNest.DList.Count;\n  if not Assigned(fOnModifyNestedPartsSubscription) then\n  begin\n    fOnModifyNestedPartsSubscription := (fNest.DList).OnModifiedEP.SubscribeFirst();\n    fOnModifyNestedPartsSubscription.OnEvent := self.HandleNestedPartsListModified;\n  end;\nend;\n\n{ *************************************************\n  Author:    iuri.f\n  Date:      21-Dec-2021\n  Notes:     TFS#136728 to be called after finishing\n             operations that may copy nested parts\n  ************************************************* }\nprocedure TAutoFixNestedPartTempIDSubscription.Stop;\nbegin\n  if fPartsHaveBeenNested then\n    TNestedPartTempIDMgr.FixNCListPIDsWithNestedPartsTempID(fNest);\n\n  if Assigned(fOnModifyNestedPartsSubscription) then\n  begin\n    (fNest.DList).OnModifiedEP.RemoveSubScription(fOnModifyNestedPartsSubscription);\n    fOnModifyNestedPartsSubscription := nil;\n  end;\nend;\n{$ENDREGION} // TAutoFixNestedPartTempIDSubscription implementation\n\n{ *************************************************\n  Author:    iuri.f\n  Date:      21-Dec-2021\n  Notes:     TFS#136728 to be called before starting operations that may copy nested parts\n             *TAutoFixNestedPartTempIDSubscription reference must be held until operation ends and then Freed\n  ************************************************* }\nclass function TNestedPartTempIDMgr.StartWatchingForAutoFixingNewlyNestedPartsTempIDs(const aNest: TNest): TAutoFixNestedPartTempIDSubscription;\nbegin\n  Result := TAutoFixNestedPartTempIDSubscription.Create(aNest);\n  Result.Start();\nend;\n\n{ *************************************************\n  Author:    iuri.f\n  Date:      21-Dec-2021\n  Notes:     TFS#136728\n  ************************************************* }\nclass procedure TNestedPartTempIDMgr.ExtractDuplicateTempIdIndexesAndMaxTempIDFromNestedPartsList(const aNest: TNest; aWrongTempIDsIndexes: TList<Integer>; var lMaxTempID: Integer);\nvar\n  lExistingTempIDs: TList<LongInt>;\n  LData: TData;\n  i: Integer;\nbegin\n  lExistingTempIDs := TList<Integer>.Create();\n  try\n    for i := 1 to aNest.DList.Count - 1 do // skip 0 cause it is the sheet\n    begin\n      LData := TData(aNest.DList[i]);\n      if lExistingTempIDs.Contains(LData.TempID) then\n      begin\n        aWrongTempIDsIndexes.Add(i);\n      end\n      else\n      begin\n        lExistingTempIDs.Add(LData.TempID);\n        if LData.TempID > lMaxTempID then\n          lMaxTempID := LData.TempID;\n      end;\n    end;\n  finally\n    lExistingTempIDs.Free();\n  end;\nend;\n\n{ *************************************************\n  Author:    iuri.f\n  Date:      21-Dec-2021\n  Notes:     TFS#136728\n  ************************************************* }\nclass procedure TNestedPartTempIDMgr.FixNestedPartsTempIDs(const aNest: TNest);\nvar\n  lWrongTempIDsIndexes: TList<Integer>;\n  i, lMaxTempID: Integer;\nbegin\n  if (aNest.DList.Count > 1) then\n  begin\n    lWrongTempIDsIndexes := TList<Integer>.Create();\n    try\n      lMaxTempID := -1;\n      ExtractDuplicateTempIdIndexesAndMaxTempIDFromNestedPartsList(aNest, lWrongTempIDsIndexes, lMaxTempID);\n\n      for i in lWrongTempIDsIndexes do\n      begin\n        if (TData(aNest.DList[i]) is TSNNestedPart) then\n        begin\n          inc(lMaxTempID);\n          TSNNestedPart(aNest.DList[i]).UpdateTempIDAndNestLevelNCPID(lMaxTempID);\n        end;\n      end;\n\n    finally\n      lWrongTempIDsIndexes.Free();\n    end;\n  end;\nend;\n\n{ *************************************************\n  Author:    iuri.f\n  Date:      05-Jan-2022\n  Notes:     TFS#136728\n  ************************************************* }\nclass procedure TNestedPartTempIDMgr.FixNCListPIDsWithNestedPartsTempID(const aNest: TNest);\nvar\n  lNCColl: TNCColl;\n  lLastNCEnt, lLastNCEntParentContour: TData;\nbegin\n  for lNCColl in aNest.NCList do\n  begin\n    if lNCColl.DList.Count > 0 then\n    begin\n      lLastNCEnt := TData(lNCColl.DList[lNCColl.DList.Count-1]);\n      lLastNCEntParentContour := lLastNCEnt.GetNCParent;\n      if lLastNCEntParentContour <> nil then\n        lNCColl.PID := lLastNCEntParentContour.DataParent.TempID;\n    end;\n  end;\nend;\n\nend."

var unit = parseTextToUnit(text);
console.log(JSON.stringify(unit, null, 4));

// var stackLines = "9 \n8 \n7 \n6 \n5 \n;Random comment \n4 \n3 \n2 \n1 \n0"
// var line=null;
// var it = new StackLinesIterator(stackLines);
// while((line =it.getNextLine()) ){
//     console.log(line);
// }

// var text = "class function StartWatchingForAutoFixingNewlyNestedPartsTempIDs(const aNest: TNest): TAutoFixNestedPartTempIDSubscription;"
// console.log(text.substring(0,text.length-1));


//var method = '+AddFileToQueue(QueueDrive : char ; QueueFileName,NCFilename,TaskName,Material,SheetName : string ; CutTime,Thickness : double ; NumSheets, STQTY : integer) ;'

//console.log(CreateNewMethod(method));

