//import parseDelphiUnitToUml from "../src/delphiParserToUml.js"
//import {CreateNewMethod} from "../src/model/delphiMethod.js"
import { parseTextToUnit } from "../src/model/delphiUnit.js"
import {StackLinesIterator}from "../src/delphiParserToActivity"

//var text = "unit PartTimeDataManager; \n \ninterface \n \nuses \n  IntfDataPartTimes, \n  Collectn; \n \ntype \n  TPartTimeData = class \n    NestID: integer; \n    NestedPartID: integer; \n    PartTime: double; \n    constructor create(aNestedPartID,aNestID: integer; aPartTime: double); \n  end; \n \n  TPartTimeDataManager = class \n   private \n    fPartTimeAccumulator: IPartTimeAccumulator; \n    fPartTimeProportionList: TSNCollection; \n    procedure NormalizePartTimeProportionList(aPartTimeProportionList: TSNCollection); \n    procedure ApplyPartTimeProportionList(aProcessNum: integer; aTime: double; aValueType: PartTimeValue_Enum); \n   public \n    SubMultiplier: integer; \n    constructor create; \n    destructor Destroy; override; \n    procedure SetPartTimeAccumulator(aPartTimeAccumulator: IPartTimeAccumulator); \n    procedure SetPartTimeProportionList(aPartTimeProportionList: TSNCollection); \n    procedure AddPartCuttingTime(aProcessNum: integer; aTime: double); \n    procedure AddPartPiercingTime(aProcessNum: integer; aTime: double); \n    procedure AddPartTravelTime(aProcessNum: integer; aTime: double); \n  end; \n \n \nimplementation \n \nuses \n  PartTimeProportion, \n  wsk; \n \n{ TPartTimeDataManager } \n \n{----------------------------------------------------------------------------- \n  Procedure: AddPartCuttingTime \n  Author:    jamess \n  Date:      06-Jan-2016 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.AddPartCuttingTime(aProcessNum: integer; aTime: double); \nbegin \n  if (fPartTimeProportionList <> nil) and (fPartTimeProportionList.Count > 0) and (aTime > 0) then \n    ApplyPartTimeProportionList(aProcessNum,aTime,PartTimeValue_CuttingTime); \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: AddPartPiercingTime \n  Author:    jamess \n  Date:      06-Jan-2016 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.AddPartPiercingTime(aProcessNum: integer; aTime: double); \nbegin \n  if (fPartTimeProportionList <> nil) and (fPartTimeProportionList.Count > 0) and (aTime > 0) then \n    ApplyPartTimeProportionList(aProcessNum,aTime,PartTimeValue_PierceTime); \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: AddPartTravelTime \n  Author:    jamess \n  Date:      06-Jan-2016 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.AddPartTravelTime(aProcessNum: integer; aTime: double); \nbegin \n  if (fPartTimeProportionList <> nil) and (fPartTimeProportionList.Count > 0) and (aTime > 0) then \n    ApplyPartTimeProportionList(aProcessNum,aTime,PartTimeValue_TravelTime); \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: ApplyPartTimeProportionList \n  Author:    jamess \n  Date:      17-Dec-2015 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.ApplyPartTimeProportionList(aProcessNum: integer; aTime: double; aValueType: PartTimeValue_Enum); \nvar \n  i: integer; \n  lPTPData: TPartTimeProportionData; \nbegin \n  if fPartTimeAccumulator <> nil then \n  begin \n    if (fPartTimeProportionList <> nil) and (fPartTimeProportionList.Count > 0) then \n    begin \n      if (SubMultiplier > 1) then \n        aTime := aTime * SubMultiplier; \n      for i := 0 to fPartTimeProportionList.Count - 1 do \n      begin \n        lPTPData := TPartTimeProportionData(fPartTimeProportionList[i]); \n        fPartTimeAccumulator.AddPartTime(lPTPData.NestID,aProcessNum,(aTime * lPTPData.TimeProportion),aValueType); \n      end; \n    end; \n  end; \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: create \n  Author:    jamess \n  Date:      16-Dec-2015 \n  Notes: \n-----------------------------------------------------------------------------} \nconstructor TPartTimeDataManager.create; \nbegin \n  inherited create; \n  fPartTimeAccumulator := nil; \n  SubMultiplier := 1; \nend; \n \n \n{----------------------------------------------------------------------------- \n  Procedure: destroy \n  Author:    jamess \n  Date:      16-Dec-2015 \n  Notes: \n-----------------------------------------------------------------------------} \ndestructor TPartTimeDataManager.destroy; \nbegin \n//  fPartTimeAccumulator.Release; \n//  fPartTimeDataList.Destroy; \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: NormalizePartTimeProportionList \n  Author:    jamess \n  Date:      17-Dec-2015 \n  Notes:     See if all proportions for this move add up to 1, and maybe fix... \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.NormalizePartTimeProportionList(aPartTimeProportionList: TSNCollection); \nvar \n  i: integer; \n  lPTPTotal: double; \n  lPTPData: TPartTimeProportionData; \nbegin \n  lPTPTotal := 0.0; \n  for i := 0 to aPartTimeProportionList.Count - 1 do \n  begin \n    lPTPData := TPartTimeProportionData(aPartTimeProportionList[i]); \n    lPTPTotal := lPTPTotal + lPTPData.TimeProportion; \n  end; \n  if notAlmostZero(1 - lPTPTotal) then  // Something went wrong determining part proportions. \n  begin \n    if lPTPTotal > 1 then  // only normalize if proportions would increase total time \n    begin \n      for i := 0 to aPartTimeProportionList.Count - 1 do \n      begin \n        lPTPData := TPartTimeProportionData(aPartTimeProportionList[i]); \n        // this modifies the list attached to the TNCData, but that should be ok. \n        lPTPData.TimeProportion := lPTPData.TimeProportion * 1/lPTPTotal; \n      end; \n    end; \n  end; \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: SetPartTimeAccumulator \n  Author:    jamess \n  Date:      21-Dec-2015 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.SetPartTimeAccumulator(aPartTimeAccumulator: IPartTimeAccumulator); \nbegin \n  fPartTimeAccumulator := aPartTimeAccumulator; \nend; \n \n{----------------------------------------------------------------------------- \n  Procedure: SetPartTimeProportionList \n  Author:    jamess \n  Date:      06-Jan-2016 \n  Notes: \n-----------------------------------------------------------------------------} \nprocedure TPartTimeDataManager.SetPartTimeProportionList(aPartTimeProportionList: TSNCollection); \nbegin \n  if aPartTimeProportionList <> fPartTimeProportionList then \n  begin \n    fPartTimeProportionList := aPartTimeProportionList; \n    if (fPartTimeProportionList <> nil) and (fPartTimeProportionList.Count > 0) then \n      NormalizePartTimeProportionList(fPartTimeProportionList); \n  end; \nend; \n \n{ TPartTimeData } \n \n{----------------------------------------------------------------------------- \n  Procedure: create \n  Author:    jamess \n  Date:      17-Dec-2015 \n  Notes: \n-----------------------------------------------------------------------------} \nconstructor TPartTimeData.create(aNestedPartID,aNestID: integer; aPartTime: double); \nbegin \n  NestedPartID := aNestedPartID; \n  NestID := aNestID; \n  PartTime := aPartTime; \nend; \n \nend.";
//var text = "unit TMSScripterFactory; \n \ninterface \n \nuses \n  atPascal; \n \nfunction CreateScripter: TatPascalScripter; \n \nimplementation \n \nuses \n  ap_Classes, ap_Windows, ap_System, ap_SysUtils, ap_Dialogs, ap_Math, \n  ap_Variants, ap_IniFiles, ap_Messages, ap_Controls, ap_Forms, ap_StdCtrls, \n  sntms_System, sntms_smallPost, sntms_Small, sntms_Collectn, sntms_post2, \n  sntms_PostPST, sntms_dataNC, sntms_dataNCBevel, sntms_SheetInfoObj, \n  sntms_DataGeoLiteElement, sntms_NCICFGReader, System.SysUtils; \n \nprocedure LoadNeededScriptLibraries(aScripter: TatPascalScripter); \nbegin \n  try \n      // Add Classes \n    aScripter.AddLibrary(TatClassesLibrary); \n    aScripter.AddLibrary(TatWindowsLibrary); \n    aScripter.AddLibrary(TatDelphiSystemLibrary); \n    aScripter.AddLibrary(TatSysUtilsLibrary); \n    aScripter.AddLibrary(TatDialogsLibrary); \n    aScripter.AddLibrary(TatMathLibrary); \n    aScripter.AddLibrary(TatVariantsLibrary); \n    aScripter.AddLibrary(TatIniFilesLibrary); \n    aScripter.AddLibrary(TatMessagesLibrary); \n    aScripter.AddLibrary(TatControlsLibrary); \n    aScripter.AddLibrary(TatFormsLibrary); \n    aScripter.AddLibrary(TatStdCtrlsLibrary); \n    aScripter.AddLibrary(TatSNSystemLibrary); \n    // Small \n    aScripter.AddLibrary(TatsmallPostLibrary); \n    aScripter.AddLibrary(TatSmallLibrary); \n    aScripter.AddLibrary(TatCollectnLibrary); \n    aScripter.AddLibrary(TatPost2Library); \n    // PostPST \n    aScripter.AddLibrary(TatPostPSTLibrary); \n    aScripter.AddLibrary(TatdataNCLibrary); \n    aScripter.AddLibrary(TatdataNCBevelLibrary); \n    aScripter.AddLibrary(TatSheetInfoObjLibrary); \n    aScripter.AddLibrary(TatDataGeoLiteElementLibrary); \n    aScripter.AddLibrary(TatNCICFGReaderLibrary); \n  except \n      on E: Exception do \n      begin \n        raise Exception.Create('LoadNeededScriptLibraries failed with message: ' + E.Message); \n      end; \n  end; \nend; \n \nprocedure RegisterGlobalConstants(aScripter: TatPascalScripter); \nbegin \n  aScripter.AddConstant('Pi', Pi); \nend; \n \nprocedure RegisterGlobalMethods \n  (aScripter: TatPascalScripter); \nbegin \n \nend; \n \nfunction CreateScripter : TatPascalScripter; \nvar \n  lScripter: TatPascalScripter; \nbegin; \n  lScripter := TatPascalScripter.create(nil); \n  RegisterGlobalMethods(lScripter); \n  RegisterGlobalConstants(lScripter); \n  LoadNeededScriptLibraries(lScripter); \n  Result := lScripter; \nend; \n \nend.";
//var text = "unit PostScript_TMS_Optimized; \n \ninterface \n \nuses \n  DataError, \n  Script_Base, \n  // Boundary - TMS Scripting \n  atPascal; \n \ntype \n  /// <summary>Scripting with TMS Scripter with optimizations: PCU, Using multiple scripts, Uses another pas, Will not parse and fix scripts</summary> \n  /// <remarks>Used when ScriptEngine:4 in the PST</remarks> \n  TPostScript_TMS_Optimized = class(TPostScripting) \n  private \n    fTMSScripter: TatPascalScripter; \n    fDoSavePrecompiledUnit: Boolean; \n    fCompileErrorRow: integer; \n    fCompileErrorCol: integer; \n    fCompileErrorMsg: string; \n \n    procedure SetScriptFile(const Value: string); override; \n    Procedure LoadScriptFile; \n    procedure Event_ScripterCompileError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n    procedure Event_ScripterRuntimeError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n    procedure HandleScripterError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n \n    function GetTMSErrorMessage(const aMainMessage: string) : string; \n    function SetCurrentScriptFromLoadedLibs(lScriptNameNoExt: string): Boolean; \n    procedure SaveScriptAsPrecompiledUnit(const aPCUPath: string); \n    procedure LoadScripter(const postFolderPath: string); \n \n  protected \n    function GetScriptEngineName: string; override; \n \n  public \n    constructor create(aErrorLog: TErrorLog; const postFolderPath: string; const aDoSaveScriptsAsPCU : Boolean); \n    destructor Destroy; override; \n \n    procedure CallNoParamsMethod(const str: string); override; \n \n    property CompileErrorRow: integer read fCompileErrorRow write fCompileErrorRow; \n    property CompileErrorCol: integer read fCompileErrorCol write fCompileErrorCol; \n    property CompileErrorMsgStr: string read fCompileErrorMsg; \n \n  end; \n \nimplementation \n \nuses \n  TMSScripterFactory, \n  ConstVarPost, \n  Small, \n  // Windows API - Self \n  System.IOUtils, \n  System.Variants, \n  StrUtils, \n  sysutils; \n \nConst \n  C_SourceFileExt: string = '.pas'; \n  C_CompiledFileExt: string = '.pcu'; \n \nconstructor TPostScript_TMS_Optimized.create(aErrorLog: TErrorLog; const postFolderPath: string; const aDoSaveScriptsAsPCU : Boolean); \nbegin \n  inherited create(aErrorLog); \n  fDoSavePrecompiledUnit := aDoSaveScriptsAsPCU; \n  fCompileErrorRow := 0; \n  fCompileErrorCol := 0; \n  NullStrictConvert := false; \n  LoadScripter(postFolderPath); \nend; \n \n{ ************************************************************** } \n// Procedure: Destroy \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \ndestructor TPostScript_TMS_Optimized.Destroy; \nbegin \n  fTMSScripter.Free; \n  inherited; \nend; \n \n{ ************************************************************** } \n// Procedure: LoadScripter \n// Author:    iurif \n// Date:      18-Jan-2021 \n// Notes:     TFS#111716 \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.LoadScripter(const postFolderPath: string); \nbegin \n  try \n    fTMSScripter := CreateScripter; \n    fTMSScripter.OnCompileError := Event_ScripterCompileError; \n    fTMSScripter.OnRuntimeError := Event_ScripterRuntimeError; \n    fTMSScripter.LibOptions.UseScriptFiles := true; \n    fTMSScripter.LibOptions.SourceFileExt := C_SourceFileExt; \n    fTMSScripter.LibOptions.CompiledFileExt := C_CompiledFileExt; \n    fTMSScripter.LibOptions.SearchPath.Add(postFolderPath); \n    fTMSScripter.OptionExplicit := true; \n    fTMSScripter.ShortBooleanEval := true; \n  except \n    on E: Exception do \n    begin \n      AddToErrorLog(ScriptError, \n        'Loading TMS Scripter Raised Exception: \" ' + E.Message + ' \"'); \n      fResultCode := PostStatus_ScriptError; \n      fCriticalFailure := true; \n    end; \n  end; \nend; \n \n{ ************************************************************** } \n// Function: GetScriptEngineName \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.GetScriptEngineName: string; \nbegin \n  Result := 'TMS Scripter - Engine 4'; \nend; \n \n{ ************************************************************** } \n// Procedure: SetScriptFile \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.SetScriptFile(const Value: string); \nbegin \n  inherited; \n  LoadScriptFile; \nend; \n \n{ ************************************************************** } \n// Procedure: LoadScriptFile \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.LoadScriptFile; \nvar \n  ldir, lScriptName, lext: string; \nbegin \n  fCompileErrorRow := 0; \n  fCompileErrorCol := 0; \n \n  FSplit(fScriptFile, ldir, lScriptName, lext); \n \n  if not SetCurrentScriptFromLoadedLibs(lScriptName) then \n  begin \n    try \n      begin \n        fTMSScripter.LoadLibrary(lScriptName); \n        // Loaded script gets added to Scripts list \n        fTMSScripter.CurrentScript := fTMSScripter.Scripts.Items[fTMSScripter.Scripts.Count - 1]; \n      end \n    except \n      on E: EAbort do \n      begin \n        AddToErrorLog(ScriptError, 'TMS: Script loading has been aborted'); \n        fCriticalFailure := true; \n      end; \n      on E: Exception do \n      begin \n        fTMSScripter.CurrentScript.GetRowColFromSource(fTMSScripter.CurrentScript.Parser.ScanningInputPos, fCompileErrorRow, fCompileErrorCol); \n        AddToErrorLog(ScriptError, GetTMSErrorMessage(E.ClassName + ': ' + E.Message)); \n        fCriticalFailure := true; \n      end; \n    end; \n  end; \n \n  if (fDoSavePrecompiledUnit) then \n    SaveScriptAsPrecompiledUnit(TPath.Combine(ldir, lScriptName + C_CompiledFileExt)); \nend; \n \n{ ************************************************************** } \n// Function: SetCurrentScriptFromLoadedLibs \n// Author:   iurif \n// Date:     23-Apr-2020 \n// Notes:    TFS#85504 \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.SetCurrentScriptFromLoadedLibs(lScriptNameNoExt: string): Boolean; \nvar \n  I: integer; \nbegin \n  Result := false; \n  for I := 0 to fTMSScripter.Scripts.Count - 1 do \n  begin \n    if CompareText(fTMSScripter.Scripts.Items[I].UnitName, lScriptNameNoExt) = 0 then \n    begin \n      fTMSScripter.CurrentScript := fTMSScripter.Scripts.Items[I]; \n      Result := true; \n      break; \n    end; \n  end; \nend; \n \n{ ************************************************************** } \n// Procedure: SavePrecompileUnit \n// Author:    iurif \n// Date:      23-Apr-2020 \n// Notes:     TFS#85584 \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.SaveScriptAsPrecompiledUnit(const aPCUPath: string); \nbegin \n  if (not(fCriticalFailure)) and fTMSScripter.CurrentScript.FileName.EndsWith(C_SourceFileExt) then \n  begin \n    fTMSScripter.CurrentScript.SaveCodeToFile(aPCUPath); \n  end; \nend; \n \n{ ************************************************************** } \n// Procedure: CallNoParamsMethod \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.CallNoParamsMethod(const str: string); \nbegin \n  inherited; \n  if not fCriticalFailure then \n    fTMSScripter.ExecuteSubroutine(str); \nend; \n \n{ ************************************************************** } \n// Procedure: Event_ScripterCompileError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.Event_ScripterCompileError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  HandleScripterError(Sender, msg, row, col, ShowException); \n  fResultCode := PostStatus_SyntaxError; \nend; \n \n{ ************************************************************** } \n// Procedure: Event_ScripterRuntimeError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.Event_ScripterRuntimeError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  HandleScripterError(Sender, msg, row, col, ShowException); \n  fResultCode := PostStatus_ScriptError; \nend; \n \n{ ************************************************************** } \n// Procedure: HandleScripterError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.HandleScripterError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  fCompileErrorRow := row; \n  fCompileErrorCol := col; \n  fCompileErrorMsg := IfThen(fCompileErrorMsg.Length > 0, fCompileErrorMsg + sLineBreak, '') + msg; \n  AddToErrorLog(ScriptError, GetTMSErrorMessage(msg)); \n  ShowException := false; \n  fCriticalFailure := true; \nend; \n \n{ ************************************************************** } \n// Function: GetTMSErrorMessage \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.GetTMSErrorMessage(const aMainMessage: string) : string; \nbegin \n  Result := Format('TMS Script ERROR - (Line %0:d,%1:d) - %2:s.%4:sFileName - %3:s.', \n                    [fCompileErrorRow, fCompileErrorCol, aMainMessage, fScriptFile, sLineBreak]); \n // TODO_TechDebt: try to get back -> 'Error Code Line - ' + FTMSScripter.SourceCode[Max(Row-1,0)]); \nend; \n \nend.unit PostScript_TMS_Optimized; \n \ninterface \n \nuses \n  DataError, \n  Script_Base, \n  // Boundary - TMS Scripting \n  atPascal; \n \ntype \n  /// <summary>Scripting with TMS Scripter with optimizations: PCU, Using multiple scripts, Uses another pas, Will not parse and fix scripts</summary> \n  /// <remarks>Used when ScriptEngine:4 in the PST</remarks> \n  TPostScript_TMS_Optimized = class(TPostScripting) \n  private \n    fTMSScripter: TatPascalScripter; \n    fDoSavePrecompiledUnit: Boolean; \n    fCompileErrorRow: integer; \n    fCompileErrorCol: integer; \n    fCompileErrorMsg: string; \n \n    procedure SetScriptFile(const Value: string); override; \n    Procedure LoadScriptFile; \n    procedure Event_ScripterCompileError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n    procedure Event_ScripterRuntimeError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n    procedure HandleScripterError(Sender: TObject; var msg: string; row, col: integer; var ShowException: Boolean); \n \n    function GetTMSErrorMessage(const aMainMessage: string) : string; \n    function SetCurrentScriptFromLoadedLibs(lScriptNameNoExt: string): Boolean; \n    procedure SaveScriptAsPrecompiledUnit(const aPCUPath: string); \n    procedure LoadScripter(const postFolderPath: string); \n \n  protected \n    function GetScriptEngineName: string; override; \n \n  public \n    constructor create(aErrorLog: TErrorLog; const postFolderPath: string; const aDoSaveScriptsAsPCU : Boolean); \n    destructor Destroy; override; \n \n    procedure CallNoParamsMethod(const str: string); override; \n \n    property CompileErrorRow: integer read fCompileErrorRow write fCompileErrorRow; \n    property CompileErrorCol: integer read fCompileErrorCol write fCompileErrorCol; \n    property CompileErrorMsgStr: string read fCompileErrorMsg; \n \n  end; \n \nimplementation \n \nuses \n  TMSScripterFactory, \n  ConstVarPost, \n  Small, \n  // Windows API - Self \n  System.IOUtils, \n  System.Variants, \n  StrUtils, \n  sysutils; \n \nConst \n  C_SourceFileExt: string = '.pas'; \n  C_CompiledFileExt: string = '.pcu'; \n \nconstructor TPostScript_TMS_Optimized.create(aErrorLog: TErrorLog; const postFolderPath: string; const aDoSaveScriptsAsPCU : Boolean); \nbegin \n  inherited create(aErrorLog); \n  fDoSavePrecompiledUnit := aDoSaveScriptsAsPCU; \n  fCompileErrorRow := 0; \n  fCompileErrorCol := 0; \n  NullStrictConvert := false; \n  LoadScripter(postFolderPath); \nend; \n \n{ ************************************************************** } \n// Procedure: Destroy \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \ndestructor TPostScript_TMS_Optimized.Destroy; \nbegin \n  fTMSScripter.Free; \n  inherited; \nend; \n \n{ ************************************************************** } \n// Procedure: LoadScripter \n// Author:    iurif \n// Date:      18-Jan-2021 \n// Notes:     TFS#111716 \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.LoadScripter(const postFolderPath: string); \nbegin \n  try \n    fTMSScripter := CreateScripter; \n    fTMSScripter.OnCompileError := Event_ScripterCompileError; \n    fTMSScripter.OnRuntimeError := Event_ScripterRuntimeError; \n    fTMSScripter.LibOptions.UseScriptFiles := true; \n    fTMSScripter.LibOptions.SourceFileExt := C_SourceFileExt; \n    fTMSScripter.LibOptions.CompiledFileExt := C_CompiledFileExt; \n    fTMSScripter.LibOptions.SearchPath.Add(postFolderPath); \n    fTMSScripter.OptionExplicit := true; \n    fTMSScripter.ShortBooleanEval := true; \n  except \n    on E: Exception do \n    begin \n      AddToErrorLog(ScriptError, \n        'Loading TMS Scripter Raised Exception: \" ' + E.Message + ' \"'); \n      fResultCode := PostStatus_ScriptError; \n      fCriticalFailure := true; \n    end; \n  end; \nend; \n \n{ ************************************************************** } \n// Function: GetScriptEngineName \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.GetScriptEngineName: string; \nbegin \n  Result := 'TMS Scripter - Engine 4'; \nend; \n \n{ ************************************************************** } \n// Procedure: SetScriptFile \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.SetScriptFile(const Value: string); \nbegin \n  inherited; \n  LoadScriptFile; \nend; \n \n{ ************************************************************** } \n// Procedure: LoadScriptFile \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.LoadScriptFile; \nvar \n  ldir, lScriptName, lext: string; \nbegin \n  fCompileErrorRow := 0; \n  fCompileErrorCol := 0; \n \n  FSplit(fScriptFile, ldir, lScriptName, lext); \n \n  if not SetCurrentScriptFromLoadedLibs(lScriptName) then \n  begin \n    try \n      begin \n        fTMSScripter.LoadLibrary(lScriptName); \n        // Loaded script gets added to Scripts list \n        fTMSScripter.CurrentScript := fTMSScripter.Scripts.Items[fTMSScripter.Scripts.Count - 1]; \n      end \n    except \n      on E: EAbort do \n      begin \n        AddToErrorLog(ScriptError, 'TMS: Script loading has been aborted'); \n        fCriticalFailure := true; \n      end; \n      on E: Exception do \n      begin \n        fTMSScripter.CurrentScript.GetRowColFromSource(fTMSScripter.CurrentScript.Parser.ScanningInputPos, fCompileErrorRow, fCompileErrorCol); \n        AddToErrorLog(ScriptError, GetTMSErrorMessage(E.ClassName + ': ' + E.Message)); \n        fCriticalFailure := true; \n      end; \n    end; \n  end; \n \n  if (fDoSavePrecompiledUnit) then \n    SaveScriptAsPrecompiledUnit(TPath.Combine(ldir, lScriptName + C_CompiledFileExt)); \nend; \n \n{ ************************************************************** } \n// Function: SetCurrentScriptFromLoadedLibs \n// Author:   iurif \n// Date:     23-Apr-2020 \n// Notes:    TFS#85504 \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.SetCurrentScriptFromLoadedLibs(lScriptNameNoExt: string): Boolean; \nvar \n  I: integer; \nbegin \n  Result := false; \n  for I := 0 to fTMSScripter.Scripts.Count - 1 do \n  begin \n    if CompareText(fTMSScripter.Scripts.Items[I].UnitName, lScriptNameNoExt) = 0 then \n    begin \n      fTMSScripter.CurrentScript := fTMSScripter.Scripts.Items[I]; \n      Result := true; \n      break; \n    end; \n  end; \nend; \n \n{ ************************************************************** } \n// Procedure: SavePrecompileUnit \n// Author:    iurif \n// Date:      23-Apr-2020 \n// Notes:     TFS#85584 \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.SaveScriptAsPrecompiledUnit(const aPCUPath: string); \nbegin \n  if (not(fCriticalFailure)) and fTMSScripter.CurrentScript.FileName.EndsWith(C_SourceFileExt) then \n  begin \n    fTMSScripter.CurrentScript.SaveCodeToFile(aPCUPath); \n  end; \nend; \n \n{ ************************************************************** } \n// Procedure: CallNoParamsMethod \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.CallNoParamsMethod(const str: string); \nbegin \n  inherited; \n  if not fCriticalFailure then \n    fTMSScripter.ExecuteSubroutine(str); \nend; \n \n{ ************************************************************** } \n// Procedure: Event_ScripterCompileError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.Event_ScripterCompileError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  HandleScripterError(Sender, msg, row, col, ShowException); \n  fResultCode := PostStatus_SyntaxError; \nend; \n \n{ ************************************************************** } \n// Procedure: Event_ScripterRuntimeError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.Event_ScripterRuntimeError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  HandleScripterError(Sender, msg, row, col, ShowException); \n  fResultCode := PostStatus_ScriptError; \nend; \n \n{ ************************************************************** } \n// Procedure: HandleScripterError \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nprocedure TPostScript_TMS_Optimized.HandleScripterError(Sender: TObject; \n  var msg: string; row, col: integer; var ShowException: Boolean); \nbegin \n  fCompileErrorRow := row; \n  fCompileErrorCol := col; \n  fCompileErrorMsg := IfThen(fCompileErrorMsg.Length > 0, fCompileErrorMsg + sLineBreak, '') + msg; \n  AddToErrorLog(ScriptError, GetTMSErrorMessage(msg)); \n  ShowException := false; \n  fCriticalFailure := true; \nend; \n \n{ ************************************************************** } \n// Function: GetTMSErrorMessage \n// Author:    iurif \n// Date:      22-May-2020 \n// Notes: \n{ ************************************************************** } \nfunction TPostScript_TMS_Optimized.GetTMSErrorMessage(const aMainMessage: string) : string; \nbegin \n  Result := Format('TMS Script ERROR - (Line %0:d,%1:d) - %2:s.%4:sFileName - %3:s.', \n                    [fCompileErrorRow, fCompileErrorCol, aMainMessage, fScriptFile, sLineBreak]); \n // TODO_TechDebt: try to get back -> 'Error Code Line - ' + FTMSScripter.SourceCode[Max(Row-1,0)]); \nend; \n \nend.";

var text = "TNCColl = class(TCadColl)\r\n  private\r\n    SimulateNoteStr: boolean; \/\/ Uses for simulation.\r\n    procedure GetNCByContinuity_AsNCOllsRegular(AContourNCList: TSncollection);\r\n  protected\r\n    function GetProcessNum1: byte; override;\r\n  public\r\n    NID: Integer; { Nest ID }\r\n  end;"

var unit = parseTextToUnit(text);
console.log(JSON.stringify(unit, null, 4));

// var stackLines = "9 \n8 \n7 \n6 \n5 \n;Random comment \n4 \n3 \n2 \n1 \n0"
// var line=null;
// var it = new StackLinesIterator(stackLines);
// while((line =it.getNextLine()) ){
//     console.log(line);
// }
 


//var method = '+AddFileToQueue(QueueDrive : char ; QueueFileName,NCFilename,TaskName,Material,SheetName : string ; CutTime,Thickness : double ; NumSheets, STQTY : integer) ;'

//console.log(CreateNewMethod(method));

